import psycopg2
from psycopg2.extras import RealDictCursor
import threading, asyncio, asyncpg
import db
import os
from tkinter import messagebox as mbox

# Função de conexão com o banco
def get_db_connection():
    return psycopg2.connect(
        host="db.vnfqxgvpqulcyvporwem.supabase.co",
        database="postgres",
        user="postgres",
        password="DOMMATI@2025",
        port=5432
    )

# Função para executar SELECT e retornar lista de dicionários
def fetch_all(query, params=None):
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    cur.execute(query, params or ())
    rows = cur.fetchall()
    cur.close()
    conn.close()
    return rows

# Função para executar INSERT, UPDATE, DELETE
def execute_query(query, params=None):
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute(query, params or ())
    conn.commit()
    cur.close()
    conn.close()

    # RECRIAR a tabela itens com a estrutura correta
    cur.execute("DROP TABLE IF EXISTS itens CASCADE")
    
    cur.execute("""
        CREATE TABLE itens (
            id SERIAL PRIMARY KEY,
            obra_id INTEGER NOT NULL,
            categoria_id INTEGER NOT NULL,
            nome TEXT NOT NULL,
            numero_serie TEXT,
            qtd_total INTEGER DEFAULT 0,
            qtd_estoque INTEGER DEFAULT 0,
            qtd_em_uso INTEGER DEFAULT 0,
            condicao TEXT,
            status TEXT,
            possui TEXT DEFAULT 'Sim',
            funcionando TEXT DEFAULT 'Sim',
            observacao TEXT,
            FOREIGN KEY (obra_id) REFERENCES obras (id),
            FOREIGN KEY (categoria_id) REFERENCES categorias (id)
        )
    """)

    # Manter as outras tabelas como estão
    cur.execute("""
        CREATE TABLE IF NOT EXISTS obras (
            id SERIAL PRIMARY KEY,
            nome TEXT UNIQUE NOT NULL
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS categorias (
            id SERIAL PRIMARY KEY,
            nome TEXT UNIQUE NOT NULL
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS movimentacoes (
            id SERIAL PRIMARY KEY,
            item_id INTEGER NOT NULL,
            data TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            tipo TEXT NOT NULL,
            quantidade INTEGER NOT NULL,
            observacao TEXT,
            responsavel TEXT,
            FOREIGN KEY (item_id) REFERENCES itens (id)
        )
    """)

    # Popular tabelas iniciais
    obras = ["Domma", "Seleto Primavera", "Unic São Gonçalo", "PRIME Caxias",
             "LIV Primavera", "Reserva Equitativa", "Encantado", "Seleto Inhaúma"]
    categorias = ["Notebook", "Mouse", "Teclado", "Carregador", "Monitor",
                  "Relógio de Ponto", "Firewall", "Switch", "Roteador", "Nobreak",
                  "DVR das Câmeras", "Câmeras"]

    for o in obras:
        cur.execute("INSERT INTO obras (nome) VALUES (%s) ON CONFLICT (nome) DO NOTHING", (o,))
    for c in categorias:
        cur.execute("INSERT INTO categorias (nome) VALUES (%s) ON CONFLICT (nome) DO NOTHING", (c,))

    conn.commit()
    cur.close()
    conn.close()
    print("[INFO] Banco de dados configurado com estrutura correta!")
# <<< FIM

# --- Funções utilitárias ---

def get_obra_id(obra_nome):
    rows = fetch_all("SELECT id FROM obras WHERE nome = %s", (obra_nome,))
    return rows[0]['id'] if rows else None

def get_dashboard_stats(obra_id):
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    cur.execute("""
        SELECT
            COALESCE(SUM(qtd_total),0) as total,
            COALESCE(SUM(qtd_em_uso),0) as em_uso,
            COALESCE(SUM(qtd_estoque),0) as disponivel
        FROM itens WHERE obra_id = %s
    """, (obra_id,))
    stats = cur.fetchone() or {}

    cur.execute("""
        SELECT COUNT(*) as manutencao
        FROM itens
        WHERE obra_id = %s AND status IN ('Em Manutenção', 'Quebrado')
    """, (obra_id,))
    manutencao = cur.fetchone() or {}

    conn.close()

    return {
        "total": stats.get('total', 0),
        "em_uso": stats.get('em_uso', 0),
        "disponivel": stats.get('disponivel', 0),
        "manutencao": manutencao.get('manutencao', 0)
    }

def get_items_by_obra(obra_id, search_term=""):
    query = """
        SELECT i.*, c.nome as categoria_nome
        FROM itens i
        JOIN categorias c ON i.categoria_id = c.id
        WHERE i.obra_id = %s
    """
    params = [obra_id]
    if search_term:
        query += " AND (i.nome ILIKE %s OR i.numero_serie ILIKE %s)"
        params.extend([f"%{search_term}%", f"%{search_term}%"])
    return fetch_all(query, tuple(params))

def log_movement(cur, item_id, tipo, quantidade, observacao, responsavel=None):
    """Função genérica que grava qualquer movimentação no banco."""
    cur.execute("""
        INSERT INTO movimentacoes (item_id, tipo, quantidade, observacao, responsavel, data)
        VALUES (%s, %s, %s, %s, %s, NOW())
    """, (item_id, tipo, quantidade, observacao, responsavel))


# ----------------------------
# NOVAS FUNÇÕES ESPECÍFICAS
# ----------------------------

def dar_baixa_item(item_id, quantidade, observacao, responsavel):
    """Registra uma baixa de estoque com o usuário logado."""
    conn = get_db_connection()
    try:
        cur = conn.cursor()
        log_movement(cur, item_id, "baixa", quantidade, observacao, responsavel)
        conn.commit()
        return True, "Baixa registrada com sucesso!"
    except Exception as e:
        conn.rollback()
        return False, f"Erro ao registrar baixa: {e}"
    finally:
        conn.close()

def transfer_item(item_id, obra_id_destino, destino_nome, quantidade, observacao, responsavel):
    """
    Transfere apenas 'quantidade' do item para outra obra.
    Se a obra destino já possui o mesmo item (mesmo nome + categoria), soma.
    Caso contrário, cria um novo registro.
    """
    conn = get_db_connection()
    try:
        cur = conn.cursor()

        # 1️⃣ Busca o item original
        cur.execute("SELECT nome, categoria_id, qtd_estoque, qtd_em_uso, condicao, status FROM itens WHERE id = %s", (item_id,))
        item = cur.fetchone()
        if not item:
            raise Exception("Item não encontrado para transferência.")

        nome, categoria_id, qtd_estoque, qtd_em_uso, condicao, status = item

        if quantidade > qtd_estoque:
            raise Exception(f"Quantidade solicitada ({quantidade}) maior que o estoque disponível ({qtd_estoque}).")

        # 2️⃣ Atualiza obra origem: decrementa quantidade
        novo_estoque_origem = qtd_estoque - quantidade
        cur.execute("UPDATE itens SET qtd_estoque = %s WHERE id = %s", (novo_estoque_origem, item_id))

        # 3️⃣ Verifica se já existe item igual na obra destino
        cur.execute("""
            SELECT id, qtd_estoque FROM itens
            WHERE obra_id = %s AND nome = %s AND categoria_id = %s
        """, (obra_id_destino, nome, categoria_id))
        destino = cur.fetchone()

        if destino:
            # Atualiza quantidade no destino
            destino_id, qtd_destino = destino
            cur.execute("UPDATE itens SET qtd_estoque = %s WHERE id = %s",
                        (qtd_destino + quantidade, destino_id))
            destino_item_id = destino_id
        else:
            # Cria novo item na obra destino
            cur.execute("""
                INSERT INTO itens (obra_id, categoria_id, nome, numero_serie, qtd_total, qtd_estoque, qtd_em_uso, condicao, status)
                SELECT %s, categoria_id, nome, numero_serie, %s, %s, 0, condicao, status
                FROM itens WHERE id = %s
                RETURNING id
            """, (obra_id_destino, quantidade, quantidade, item_id))
            destino_item_id = cur.fetchone()[0]

        # 4️⃣ Registra movimentações no log (com origem/destino mais claros)
            # Busca nome da obra de origem para registrar corretamente
            cur.execute("SELECT nome FROM obras WHERE id = (SELECT obra_id FROM itens WHERE id = %s)", (item_id,))
        obra_origem = cur.fetchone()
        nome_origem = obra_origem[0] if obra_origem else "Obra desconhecida"

        # Saída
        log_movement(
            cur,
            item_id,
            "Transferência (Saída)",
            quantidade,
            f"{observacao} | Destino: {destino_nome}",
            responsavel
        )

        # Entrada
        log_movement(
            cur,
            destino_item_id,
            "Transferência (Entrada)",
            quantidade,
            f"Recebido de {nome_origem}",
            responsavel
        )

        conn.commit()
        return True, f"{quantidade} unidade(s) transferida(s) para {destino_nome}."

    except Exception as e:
        conn.rollback()
        return False, f"Erro ao transferir item: {e}"
    finally:
        conn.close()

# >>> INÍCIO (simplificar funções add_item e update_item)
# >>> INÍCIO (corrigir add_item para usar qtd_em_uso)
# >>> INÍCIO (substituir APENAS estas 3 funções)
def add_item(data, responsavel=None):
    conn = get_db_connection()
    cur = conn.cursor()
    
    # CORREÇÃO: Usar qtd_em_uso em vez de qtd_uso
    cur.execute("""
        INSERT INTO itens (obra_id, categoria_id, nome, numero_serie, qtd_total, qtd_estoque, qtd_em_uso, condicao, status)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        RETURNING id
    """, (
        data['obra_id'], 
        data['categoria_id'], 
        data['nome'], 
        data['numero_serie'],
        data['qtd_total'], 
        data['qtd_estoque'], 
        data.get('qtd_em_uso', 0),  # ← MUDEI: qtd_em_uso em vez de qtd_uso
        data['condicao'], 
        data['status']
    ))
    
    item_id = cur.fetchone()[0]
    log_movement(cur, item_id, "Entrada", data['qtd_total'], "Item novo cadastrado.", responsavel)
    conn.commit()
    conn.close()

def update_item(data, responsavel=None):
    conn = get_db_connection()
    cur = conn.cursor()
    
    # CORREÇÃO: Usar qtd_em_uso em vez de qtd_uso
    cur.execute("""
        UPDATE itens
        SET nome=%s, numero_serie=%s, categoria_id=%s, qtd_total=%s,
            qtd_em_uso=%s, qtd_estoque=%s, condicao=%s, status=%s
        WHERE id=%s
    """, (
        data['nome'], 
        data['numero_serie'], 
        data['categoria_id'], 
        data['qtd_total'],
        data.get('qtd_em_uso', 0),  # ← MUDEI: qtd_em_uso em vez de qtd_uso
        data['qtd_estoque'], 
        data['condicao'], 
        data['status'], 
        data['id']
    ))
    
    log_movement(cur, data['id'], "Atualização", 0, f"Item '{data['nome']}' atualizado.", responsavel)
    conn.commit()
    conn.close()

def devolver_item(item_id, quantidade, observacao="Retorno ao estoque", responsavel=None):
    item = fetch_all("SELECT qtd_em_uso, qtd_estoque FROM itens WHERE id=%s", (item_id,))
    if not item:
        return False, "Item não encontrado."
    item = item[0]
    if quantidade > item['qtd_em_uso']:
        return False, "Quantidade de retorno maior que o que está em uso."

    novo_em_uso = item['qtd_em_uso'] - quantidade
    novo_estoque = item['qtd_estoque'] + quantidade

    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("UPDATE itens SET qtd_em_uso=%s, qtd_estoque=%s WHERE id=%s",
                (novo_em_uso, novo_estoque, item_id))
    log_movement(cur, item_id, "Devolução", quantidade, observacao, responsavel)
    conn.commit()
    conn.close()
    return True, "Item devolvido com sucesso."

def get_categorias():
    return fetch_all("SELECT * FROM categorias ORDER BY nome")

def get_movimentacoes_do_item(item_id, limit=200):
    query = """
        SELECT
            m.data, m.tipo, m.quantidade, COALESCE(m.responsavel, '') AS responsavel,
            COALESCE(m.observacao, '') AS observacao
        FROM movimentacoes m
        WHERE m.item_id = %s
        ORDER BY m.data DESC
        LIMIT %s
    """
    return fetch_all(query, (item_id, limit))

# --- SINCRONIZAÇÃO EM TEMPO REAL ---
import threading, asyncio, asyncpg

import threading, asyncio, asyncpg

async def _listen_notifications(callback):
    conn = await asyncpg.connect(
        host="db.vnfqxgvpqulcyvporwem.supabase.co",
        user="postgres",
        password="DOMMATI@2025",
        database="postgres"
    )
    # Listener para o canal "estoque_changes"
    await conn.add_listener("estoque_changes", lambda *a: safe_callback(callback))
    while True:
        await asyncio.sleep(5)

# >>> INÍCIO (corrigir a função start_realtime_listener)
# >>> INÍCIO (desativar listener completamente - solução rápida)

# >>> INÍCIO (substituir a função start_realtime_listener por esta versão)
def start_realtime_listener(callback):
    """Função vazia - desativa completamente o listener"""
    print("[INFO] Listener de tempo real DESATIVADO")
    return None  # Não faz absolutamente nada
# <<< FIM

def safe_callback(callback):
    try:
        if callback and callable(callback):
            callback()
        else:
            print("[WARN] Listener desativado: callback inválido ou sem método associado.")
    except Exception as e:
        print(f"[ERRO] Falha ao executar callback do listener: {e}")

def get_items_simple(obra_id):
    """
    Retorna uma lista simples de itens apenas com os campos essenciais
    para comparação rápida e refresh parcial.
    """
    query = """
        SELECT id, nome, qtd_estoque, qtd_em_uso, status
        FROM itens
        WHERE obra_id = %s
        ORDER BY id
    """
    return fetch_all(query, (obra_id,))

def get_movimentacoes_por_usuario(username):
    query = """
        SELECT *
        FROM movimentacoes
        WHERE responsavel = %s
        ORDER BY data DESC
    """
    return fetch_all(query, (username,))
# --- Preferências de usuário (tema) ---

def ensure_preferences_table():
    """Cria a tabela de preferências se não existir."""
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS preferencias_usuarios (
            username TEXT PRIMARY KEY,
            tema     TEXT NOT NULL DEFAULT 'light'
        );
    """)
    conn.commit()
    cur.close()
    conn.close()


def upsert_user_theme(username: str, tema: str):
    """Salva/atualiza o tema preferido do usuário (light/dark)."""
    ensure_preferences_table()
    execute_query("""
        INSERT INTO preferencias_usuarios (username, tema)
        VALUES (%s, %s)
        ON CONFLICT (username) DO UPDATE SET tema = EXCLUDED.tema
    """, (username, tema))


def get_user_theme(username: str):
    """Retorna o tema salvo para o usuário ou None."""
    ensure_preferences_table()
    rows = fetch_all("SELECT tema FROM preferencias_usuarios WHERE username = %s", (username,))
    return rows[0]['tema'] if rows else None

# --- Recuperação de senha / usuários ---

def ensure_usuarios_table():
    """Cria a tabela de usuários se não existir."""
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS usuarios (
            username TEXT PRIMARY KEY,
            email    TEXT NOT NULL,
            senha    TEXT NOT NULL
        );
    """)
    conn.commit()
    cur.close()
    conn.close()

# db.py — final do arquivo (depois de ensure_usuarios_table)
# db.py — final
def ensure_notebook_schema():
    """Garante que a tabela notebooks no SQLite tenha todas as colunas necessárias."""
    from controle_estoque import db_connect_notebooks  # ajuste se já importar em db.py
    conn, cursor = db_connect_notebooks()
    cursor.execute("PRAGMA table_info(notebooks)")
    cols = {row[1] for row in cursor.fetchall()}
    if "obra" not in cols:
        cursor.execute("ALTER TABLE notebooks ADD COLUMN obra TEXT")
    if "autocad" not in cols:
        cursor.execute("ALTER TABLE notebooks ADD COLUMN autocad TEXT DEFAULT 'Não'")
    if "fotos" not in cols:
        cursor.execute("ALTER TABLE notebooks ADD COLUMN fotos TEXT DEFAULT 'Não'")
    if "perifericos" not in cols:
        cursor.execute("ALTER TABLE notebooks ADD COLUMN perifericos TEXT")
    conn.commit()
    conn.close()


def get_usuario(username: str):
    """Retorna dict com username, email, senha ou None."""
    ensure_usuarios_table()
    rows = fetch_all("SELECT username, email, senha FROM usuarios WHERE username = %s", (username,))
    return rows[0] if rows else None


def upsert_usuario(username: str, email: str, senha: str):
    """Opcional: cadastra/atualiza usuário rapidamente via app."""
    ensure_usuarios_table()
    execute_query(
        """
        INSERT INTO usuarios (username, email, senha)
        VALUES (%s, %s, %s)
        ON CONFLICT (username) DO UPDATE SET email = EXCLUDED.email, senha = EXCLUDED.senha
        """,
        (username, email, senha)
    )

def get_movimentacoes_por_periodo(obra_id, data_inicio, data_fim):
    """
    Retorna todas as movimentações de estoque para uma obra dentro de um período.
    """
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)

    query = """
        SELECT m.id, m.item_id, i.nome, i.obra_id,
           m.tipo, m.quantidade, m.observacao,
           m.responsavel, m.data
        FROM movimentacoes m
        JOIN itens i ON i.id = m.item_id
        WHERE i.obra_id = %s
        AND m.data::date BETWEEN %s AND %s
        ORDER BY m.data DESC
    """
    cur.execute(query, (obra_id, data_inicio, data_fim))
    resultados = cur.fetchall()

    cur.close()
    conn.close()
    return resultados
# >>> INÍCIO (adicionar função para garantir estrutura da tabela)

def ensure_correct_table_structure():
    """Garante que a tabela itens tem todas as colunas necessárias"""
    conn = get_db_connection()
    try:
        cur = conn.cursor()
        
        # Verificar se qtd_em_uso existe, se não, criar
        cur.execute("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'itens' AND column_name = 'qtd_em_uso'
        """)
        if not cur.fetchone():
            print("[INFO] Adicionando coluna qtd_em_uso à tabela itens...")
            cur.execute("ALTER TABLE itens ADD COLUMN qtd_em_uso INTEGER DEFAULT 0")
        
        # Verificar se qtd_uso existe (antiga coluna), se existir, remover
        cur.execute("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'itens' AND column_name = 'qtd_uso'
        """)
        if cur.fetchone():
            print("[INFO] Removendo coluna obsoleta qtd_uso da tabela itens...")
            # Primeiro precisamos garantir que não há dados dependentes
            # Como é uma coluna numérica, podemos simplesmente migrar os dados se necessário
            cur.execute("UPDATE itens SET qtd_em_uso = qtd_uso WHERE qtd_em_uso = 0 AND qtd_uso IS NOT NULL")
            cur.execute("ALTER TABLE itens DROP COLUMN qtd_uso")
        
        conn.commit()
        print("[INFO] Estrutura da tabela itens verificada e corrigida com sucesso!")
        
    except Exception as e:
        print(f"[ERRO] Falha ao verificar estrutura da tabela: {e}")
        conn.rollback()
    finally:
        conn.close()

# Chamar esta função no setup_database
def setup_database():
    # ... código existente das CREATE TABLE ...
    
    # VERIFICAR E CORRIGIR ESTRUTURA DA TABELA
    ensure_correct_table_structure()
# <<< FIM

# >>> PATCH: delete_item robusto com checagem de tabela e transação limpa
def delete_item(item_id: int) -> tuple[bool, str]:
    """Exclui o item com segurança. Remove registros em tabelas dependentes se existirem."""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        # Helper: checa se a tabela existe (evita abortar transação)
        def _table_exists(table_name: str) -> bool:
            # Usa schema 'public' por padrão
            full = table_name if "." in table_name else f"public.{table_name}"
            cur.execute("SELECT to_regclass(%s)", (full,))
            return cur.fetchone()[0] is not None

        # 1) Apaga movimentações vinculadas (se a tabela existir)
        if _table_exists("movimentacoes"):
            cur.execute("DELETE FROM movimentacoes WHERE item_id = %s", (item_id,))

        # 2) Apaga anexos (se você tiver essa tabela; se não existir, é ignorado)
        if _table_exists("anexos"):
            cur.execute("DELETE FROM anexos WHERE item_id = %s", (item_id,))

        # 3) Apaga o item
        cur.execute("DELETE FROM itens WHERE id = %s", (item_id,))
        if cur.rowcount == 0:
            conn.rollback()
            return False, "Item não encontrado."

        conn.commit()
        return True, "Item excluído com sucesso."
    except Exception as e:
        conn.rollback()
        return False, f"Erro ao excluir item: {e}"
    finally:
        try:
            cur.close()
        finally:
            conn.close()
# <<< PATCH

def get_item_nome(item_id: int) -> str:
    """Retorna o nome do item a partir do ID."""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("SELECT nome FROM itens WHERE id = %s", (item_id,))
        r = cur.fetchone()
        return r[0] if r else str(item_id)
    except Exception:
        return str(item_id)
    finally:
        conn.close()


